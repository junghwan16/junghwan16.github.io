---
layout: single
title: "Dynamo에서 DynamoDB로 — 논문이 서비스가 되기까지"
date: 2026-02-16 20:00:00 +0900
categories: [backend, infrastructure]
---

2007년 Amazon 내부 시스템으로 시작한 Dynamo는 2012년 AWS DynamoDB라는 완전관리형 서비스로 진화했다. 이 글에서는 Dynamo가 프로덕션에서 얻은 교훈과, DynamoDB로 넘어가면서 무엇이 바뀌었는지를 정리한다.

---

## 프로덕션에서 배운 교훈

### (N, R, W) 튜닝이 핵심이다

Dynamo의 가장 큰 장점은 클라이언트가 자신의 요구에 맞는 (N, R, W) 값을 설정할 수 있다는 것이다.

| 사용 패턴 | 설정 예시 | 설명 |
|---|---|---|
| 일반적 사용 | N=3, R=2, W=2 | 균형 잡힌 일관성과 가용성 |
| 비즈니스 로직 중재 | N=3, R=2, W=2 | 앱이 직접 충돌 해결 (장바구니 등) |
| 타임스탬프 중재 | N=3, R=2, W=2 | 최종 쓰기 승리 (단순한 데이터) |
| 고성능 읽기 엔진 | N=3, R=1, W=N | 대량 읽기, 적은 쓰기 (상품 카탈로그) |

핵심은 하나의 정답이 없다는 것이다. N은 내구성을, W와 R의 조합은 가용성과 [일관성](/backend/infrastructure/consistency/) 사이의 트레이드오프를 결정한다. 각 서비스가 자기 상황에 맞게 튜닝할 수 있는 유연성이 Dynamo가 성공한 이유 중 하나다.

### 버전 분기는 거의 일어나지 않는다

24시간 프로덕션 실험 결과, **99.94%의 요청이 단일 버전만 반환**했다. 버전 분기(여러 충돌 버전이 존재하는 상태)는 극히 드물다.

흥미로운 점은, 장애에 의한 분기보다 **동시적 쓰기에 의한 분기가 더 빈번**했다는 것이다. 주로 봇에 의해 발생했다.

### 클라이언트 주도 방식이 성능에 큰 차이를 만든다

요청 라우팅에는 두 가지 방식이 있다.

**서버 주도**

```
Client → Load Balancer → 임의 노드 → (포워딩) → 담당 노드
```

단순하지만, 중간에 포워딩이 발생해서 레이턴시가 늘어난다.

**클라이언트 주도**

```
Client (파티션 인식 라이브러리) → 담당 노드 (직접)
```

파티션 정보를 클라이언트가 알고 있으므로 올바른 노드에 직접 요청한다. **99.9분위에서 30ms 이상의 레이턴시 감소** 효과가 있었다.

다만 클라이언트가 파티션 정보를 주기적으로 폴링해야 하고, 멤버십 변경 시 동기화 지연이 있다는 트레이드오프가 있다.

---

## 성능 최적화

### 메모리 객체 버퍼

디스크 대신 메모리에 먼저 저장한 후 주기적으로 플러시하는 방식이다. **99.9분위 레이턴시가 약 5배 감소**했다.

내구성 위험은 이렇게 완화한다. N개 레플리카 중 **1개는 반드시 디스크에 쓰고(durable write)**, 나머지는 메모리만 OK. 전부 메모리도 아니고 전부 디스크도 아닌, 실용적인 타협이다.

### 균일한 부하 분산

트래픽이 적을수록 핫키 수가 줄어서 특정 노드에 부하가 몰리고, 트래픽이 많을수록 핫키가 분산돼 평균화된다. [안정 해싱](/backend/infrastructure/consistent-hashing/)의 Virtual Node 수를 조절하여 부하 분산을 최적화한다.

### 승인 제어(Admission Control)

포그라운드(사용자 요청) 레이턴시를 모니터링하는 피드백 루프다. 포그라운드가 느려지면 백그라운드 작업(anti-entropy, hinted handoff 등)을 억제한다. **포그라운드 성능이 항상 우선**이라는 원칙이다.

---

## Dynamo vs DynamoDB

| 항목 | Dynamo (논문, 2007) | DynamoDB (AWS, 2012~) |
|---|---|---|
| **배포 모델** | Amazon 내부 전용 | AWS 완전관리형 멀티테넌트 |
| **일관성 모델** | 최종 일관성, 항상 쓰기 가능 | 기본 최종 일관성 + **강한 일관성 읽기** 옵션 |
| **충돌 해결** | **클라이언트가 직접** (벡터 클럭) | **서버 측 최종 쓰기 승리** |
| **파티셔닝** | 안정 해싱, Virtual Node | 내부 안정 해싱 (추상화됨) |
| **API** | 단순 get/put | 쿼리, 스캔, 조건부 업데이트, 트랜잭션 |
| **데이터 모델** | 순수 키-값 (바이너리 blob) | 키-값 + 문서, GSI/LSI |
| **저장소 엔진** | 플러그인 (BDB, MySQL 등) | 내부 구현 |
| **멤버십** | 가십 프로토콜, 탈중앙 | AWS 중앙 관리 |
| **SLA 제어** | (N, R, W) 직접 튜닝 | AWS가 보장, 용량만 설정 |

---

## 핵심 철학 변화

가장 큰 변화는 **충돌 해결 방식**이다.

- **Dynamo**: 개발자에게 최대한의 제어권. 벡터 클럭을 이용한 클라이언트 측 충돌 해결.
- **DynamoDB**: 운영 복잡성을 AWS가 대신 감수. 서버 측 최종 쓰기 승리.

Dynamo의 "클라이언트가 충돌을 해결한다"는 철학이 DynamoDB에서는 사라졌다. 대부분의 개발자가 충돌 해결 로직을 제대로 구현하지 않았기 때문이라는 이야기가 있다. 이론적으로 우아한 설계가 실무에서는 부담이 된 셈이다.

다른 방향으로 본다면, DynamoDB는 대신 **강한 일관성 읽기** 옵션을 제공한다. 필요한 경우 읽기 시 최신 값을 보장받을 수 있다. 충돌을 허용하고 나중에 해결하는 대신, 아예 충돌이 적게 발생하도록 시스템 수준에서 해결한 것이다.

---

## 결론: 이 논문이 남긴 것

Dynamo 논문(2007)의 핵심 기여:

1. **항상 쓰기 가능(Always Writeable)** 설계로 가용성을 극대화할 수 있음을 실증했다.
2. 안정 해싱, 벡터 클럭, 느슨한 정족수, 머클 트리, 가십 프로토콜 등 **잘 알려진 기법들의 실용적 조합**이 프로덕션에서 동작함을 보여주었다.
3. (N, R, W) 파라미터로 **서비스별 트레이드오프 조정**이 가능한 유연한 아키텍처를 제시했다.

이 논문이 남긴 가장 중요한 메시지는 "최종 일관성이 프로덕션에서 충분히 실용적이다"라는 것이다. 이후 Cassandra, Riak, Voldemort 등의 NoSQL 시스템이 Dynamo의 아이디어를 기반으로 탄생했다. "모든 것을 완벽하게"가 아니라 **"비즈니스 요구에 맞게 트레이드오프하라"**는 철학은 오늘날 분산 시스템 설계의 기본 원칙이 되었다.

---

## 참고자료

- [Dynamo: Amazon's Highly Available Key-value Store](https://www.allthingsdistributed.com/files/amazon-dynamo-soho2007.pdf) — 원문
- [Dynamo 한글 번역본 (parksb)](https://parksb.github.io/papers-i-love/dynamo-amazons-highly-available-key-value-store.html)
- [Amazon DynamoDB: A Scalable, Predictably Performant, and Fully Managed NoSQL Database Service (2022)](https://www.usenix.org/system/files/atc22-elhemali.pdf) — DynamoDB 논문
- [Amazon DynamoDB Developer Guide](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/) — DynamoDB 공식 문서
