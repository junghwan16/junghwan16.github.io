---
layout: post
title: "Redis 클러스터, 언제 도입하고 어떻게 운영할까"
date: 2026-01-24 12:00:00 +0900
categories: [backend, redis]
---

단일 Redis로 충분한가요? 메모리가 부족하거나 처리량이 한계에 달했다면 클러스터를 고려할 때입니다. 핵심은 **해시 슬롯 16384개**로 데이터를 분산하고, **MOVED/ASK 리다이렉트**를 통해 클라이언트가 올바른 노드로 재시도한다는 점입니다.

## 먼저 생각해볼 것

> - 현재 Redis 메모리 사용량이 단일 서버 한계에 근접했는가?
> - 처리량(TPS)이 단일 인스턴스로 감당 가능한가?
> - 멀티키 연산(MGET, 트랜잭션)을 많이 쓰고 있는가? (클러스터에서 제약)
> - 페일오버 시 자동 복구가 필요한가?

## 스케일 업 vs 스케일 아웃

| 방식 | 설명 | 특징 |
|------|------|------|
| **스케일 업** | 하드웨어 사양 업그레이드 (Vertical) | 간단, 비용 적음, 하드웨어 한계 있음 |
| **스케일 아웃** | 장비 추가 (Horizontal) | 무한 확장 가능, 분산 처리 로직 필요 |

## Redis에서의 확장성

- **키 이빅션(eviction)이 자주 발생**: 메모리 증가 (스케일 업)
- **처리량 증가 필요**: 스케일 업만으로는 한계
  - Redis는 단일 스레드 → CPU 추가해도 활용 불가
  - **데이터를 여러 서버로 분할**하면 병렬 처리 가능 → 클러스터

## 클러스터의 기능

클러스터 모드를 사용하면:
- 추가 아키텍처 변경 없이 **수평 확장**
- **데이터 분산 처리**와 복제
- **자동 페일오버**

## 해시슬롯을 이용한 데이터 샤딩

클러스터의 모든 데이터는 **해시슬롯**에 저장됩니다.

```
총 16,384개의 해시슬롯

┌─────────────┬─────────────┬─────────────┐
│  Master #1  │  Master #2  │  Master #3  │
│ 슬롯 0-5460 │ 슬롯 5461-  │ 슬롯 10923- │
│             │    10922    │    16383    │
└─────────────┴─────────────┴─────────────┘
```

### 해시 함수

```
HASH_SLOT = CRC16(key) mod 16384
```

키를 CRC16으로 해시한 후 16384로 나눈 나머지로 슬롯이 결정됩니다.

### 노드 추가/삭제

- **노드 추가**: 기존 노드의 해시슬롯 일부를 신규 노드로 이동
- **노드 삭제**: 삭제할 노드의 슬롯을 다른 마스터로 이동 후 제외

## 해시태그

클러스터에서는 **다중 키 커맨드** (예: `MGET`)를 기본적으로 사용할 수 없습니다.

```redis
MGET user1:name user2:name  # 서로 다른 슬롯 → 실패
```

**해시태그**로 해결:

```redis
user:{123}:profile
user:{123}:account
```

`{}` 안의 값만으로 해시되어 같은 슬롯에 저장됩니다.

> 주의: 너무 많은 키가 같은 해시태그를 가지면 특정 슬롯에 데이터가 몰릴 수 있습니다.

## MOVED vs ASK

클라이언트가 잘못된 노드에 요청하면:

| 응답 | 의미 | 클라이언트 동작 |
|------|------|----------------|
| `MOVED <slot> <host:port>` | 슬롯이 이미 다른 노드로 이동 완료 | 슬롯 맵 업데이트 후 재시도 |
| `ASK <slot> <host:port>` | 슬롯 이동 중 (진행 중) | `ASKING` 후 한 번만 재시도 |

## 클러스터 제약사항

- **멀티키 연산, Lua, 트랜잭션**: 한 슬롯 안의 키만 사용 가능
- **파이프라인**: 가능
- `KEYS`, `FLUSHALL` 등 전역 커맨드: 제한/차단
- **복제본 읽기**: `READONLY`로 허용 가능하나 일관성은 eventual

## 클러스터 토폴로지

모든 노드가 **풀 메쉬(Full Mesh)** 구조로 연결됩니다.

```
N개 노드 → 각 노드는 N-1개의 TCP 연결 유지
```

**클러스터 버스**: 노드 간 통신용 별도 포트 (일반 포트 + 10000)
- 예: 6379 포트 → 클러스터 버스 16379

**가십 프로토콜**을 사용해 노드가 증가해도 메시지가 기하급수적으로 늘어나지 않습니다.

## 자동 재구성

### 자동 페일오버

마스터 장애 시 복제본을 마스터로 승격:

1. 마스터 장애 발생
2. 복제본이 다른 마스터들에게 투표 요청
3. 과반수 이상 투표 받으면 승격

### 복제본 마이그레이션

```
6001 마스터 장애 → 6005(복제본) 승격
                  ↓
           6005의 복제본은?
                  ↓
      잉여 복제본이 6005의 복제본으로 이동
```

설정:
```
cluster-allow-replica-migration yes
cluster-migration-barrier 1
```

### cluster-require-full-coverage

```
cluster-require-full-coverage yes  # 기본값
```

- `yes`: 일부 슬롯 사용 불가 시 전체 클러스터 fail
- `no`: 가용성 우선, 데이터 불완전성 허용

## 클러스터 구성

최소 3개의 마스터 노드가 필요합니다.

운영 환경에서는 보통 **3 마스터 + 3 복제본 = 6노드**로 구성합니다.

## 운영 체크리스트

**모니터링:**
- 슬롯 불일치
- 리샤딩 진행률
- 복제 지연
- `connected_clients`, `rejected_connections`, `evicted_keys`

**클라이언트:**
- 클러스터 모드 지원 드라이버 사용
- `MOVED/ASK` 리다이렉트와 재시도 처리 확인

## 리샤딩 절차

1. 새 마스터 노드 추가
2. `CLUSTER ADDSLOTS` 또는 `redis-cli --cluster reshard`로 슬롯 분배
3. 슬롯 이동 중 `ASK` 응답 발생 가능 → 클라이언트 자동 재시도 확인
4. 슬롯 이동 완료 후 `CLUSTER SLOTS`로 확인

## 장애 복구

| 상황 | 대응 |
|------|------|
| 마스터 다운 | 복제본 자동 승격. 실패 시 `CLUSTER FAILOVER` 수동 실행 |
| 슬롯 일부 비어 fail 상태 | `cluster-require-full-coverage no`로 가용성 우선 가능 |
| 연속 페일오버로 복제본 소진 | 각 마스터당 최소 1개 이상 여분 복제본 유지 |

## 정리

| 항목 | 내용 |
|------|------|
| 해시슬롯 | 16,384개, `CRC16(key) mod 16384` |
| 다중키 연산 | 해시태그 `{}` 사용 필요 |
| 노드 간 통신 | 클러스터 버스 (포트 + 10000) |
| 페일오버 | 과반수 투표로 복제본 승격 |
| 최소 구성 | 3 마스터 (권장: 3 마스터 + 3 복제본) |

## 클라이언트 구현 예시

### Python (redis-py)

```python
from redis.cluster import RedisCluster

rc = RedisCluster(
    host="node1",
    port=6379,
    decode_responses=True
)

# 단일 키 연산 - 자동 라우팅
rc.set("user:123", "data")
rc.get("user:123")

# 해시태그로 멀티키 연산
rc.mset({"{user:123}:name": "kim", "{user:123}:age": "30"})
rc.mget("{user:123}:name", "{user:123}:age")
```

MOVED/ASK 리다이렉트는 redis-py가 자동 처리한다.

### Spring Data Redis

```java
@Bean
public RedisConnectionFactory redisConnectionFactory() {
    RedisClusterConfiguration config = new RedisClusterConfiguration(
        List.of("node1:6379", "node2:6379", "node3:6379")
    );
    return new LettuceConnectionFactory(config);
}
```

---

## 리샤딩 성능 영향

슬롯 이동 중 해당 슬롯 접근 시:

| 상황 | 지연 |
|------|------|
| 슬롯 이동 전 | 0.5ms |
| 슬롯 이동 중 (ASK) | 1~2ms (재시도 포함) |
| 슬롯 이동 후 (MOVED 1회) | 0.5ms + 캐시 갱신 |

대규모 리샤딩 시 배치 크기 조절로 영향 최소화:

```bash
redis-cli --cluster reshard <host>:<port> --cluster-pipeline 100
```

---

## 자가 체크

> - 클라이언트 라이브러리가 클러스터 모드를 지원하는가?
> - 기존 코드에서 멀티키 연산을 쓰고 있다면 해시태그로 변경했는가?
> - 리샤딩 중 `ASK` 응답을 클라이언트가 처리하는가?
> - 각 마스터당 최소 1개 이상의 복제본을 두고 있는가?
